# 문자열 조작 [String Manipulation]


### LeetCode 125.Valid Palindrom 유효한 팰린드롬

<https://leetcode.com/problems/valid-palindrome/submissions/>

----
1. 직접 문자열을 입력받아 팰린드롬 여부를 확인하는 방법.  (비효율적)

```Python   
    class Solution:
    def isPalindrome(self, s: str) -> bool:
        strs = []
        for char in s:
            # isalnum()는 영문자, 숫자 여부를 판별하는 함수로, 이를 이용해 해당하는 문자만 추가했다.
            if char.isalnum():
                # 대소문자 구별하지 않게 lower()로 모두 소문자로 변환해줬다.
                strs.append(char.lower())

        while len(strs) > 1:
            if strs.pop(0) != strs.pop():
                return False

        return True
```
----

2. 데크 자료형을 이용한 최적화
```Python
    class Solution:
    def isPalindrome(self, s: str) -> bool:
        # 자료형을 데크로 선언함으로써 위의 리스트보다 속도 5배가량 향상.
        strs: Deque = collections.deque()
            
        for char in s:
            if char.isalnum():
                strs.append(char.lower())
                
        while len(strs) > 1:
            # popleft()는 속도 O(1) 이고, pop(0)은 속도가 O(n)
            if strs.popleft() != strs.pop():
                return False
            
        return True
```

Deque자료형의 popleft()는 속도 O(1) 이고, pop(0)은 속도가 O(n)이므로 <br> 
각각 n 번씩 반복할 경우, 리스트 구현은 O(n**2) , 데크의 구현은 O(n)으로 성능 차이가 커진다.


-----

3. 슬라이싱 사용 (속도와 메모리 가장 적게 사용했다.)

```Python
    class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = s.lower()
        # 정규표현식으로 영숫자가 아닌것들은 제거했다.
        s = re.sub('[^a-z0-9]', '', s)
        
        # 슬라이싱
        return s == s[::-1] 
```