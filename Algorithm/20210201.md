> # 문자열 조작 [String Manipulation]


## LeetCode 125.Valid Palindrom 유효한 팰린드롬

<https://leetcode.com/problems/valid-palindrome/submissions/>

----
### 1. 직접 문자열을 입력받아 팰린드롬 여부를 확인하는 방법.  (비효율적)

```Python   
    class Solution:
    def isPalindrome(self, s: str) -> bool:
        strs = []
        for char in s:
            # isalnum()는 영문자, 숫자 여부를 판별하는 함수로, 이를 이용해 해당하는 문자만 추가했다.
            if char.isalnum():
                # 대소문자 구별하지 않게 lower()로 모두 소문자로 변환해줬다.
                strs.append(char.lower())

        while len(strs) > 1:
            if strs.pop(0) != strs.pop():
                return False

        return True
```


### 2. 데크 자료형을 이용한 최적화
```Python
    class Solution:
    def isPalindrome(self, s: str) -> bool:
        # 자료형을 데크로 선언함으로써 위의 리스트보다 속도 5배가량 향상.
        strs: Deque = collections.deque()
            
        for char in s:
            if char.isalnum():
                strs.append(char.lower())
                
        while len(strs) > 1:
            # popleft()는 속도 O(1) 이고, pop(0)은 속도가 O(n)
            if strs.popleft() != strs.pop():
                return False
            
        return True
```

* Deque자료형의 popleft()는 속도 O(1) 이고, pop(0)은 속도가 O(n)이므로 <br> 
각각 n 번씩 반복할 경우, 리스트 구현은 O(n**2) , 데크의 구현은 O(n)으로 성능 차이가 커진다.



### 3. 슬라이싱 사용 (속도와 메모리 가장 적게 사용했다.)

```Python
    class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = s.lower()
        # 정규표현식으로 영숫자가 아닌것들은 제거했다.
        s = re.sub('[^a-z0-9]', '', s)
        
        # 슬라이싱
        return s == s[::-1] 
```

### Python 슬라이싱 예시
```Python
    S = '안녕하세요'

    S[1:4] == '녕하세'
    S[1:] == '녕하세요'
    S[:] == '안녕하세요'
    S[1:100] == '안녕하세요'
    S[-1] == '요'
    S[-4] == '녕'
    S[::-1] == '요세하녕안'
    S[::1] == '안녕하세요'
    S[::2] == '안하요'
```

## LeetCodde 344. Reverse String 문자열 뒤집기

<https://leetcode.com/problems/reverse-string/>

---

### 1. 투 포인터를 이용한 방법 
```Python
    class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        # 리스트의 인덱스 0부터 시작하기 때문에  right = len(s) - 1
        left, right = 0, len(s) - 1
        # right 가 left보다 클 경우 대칭점이 되기 때문에 while 문 중단.
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```



### 2. 파이썬다운방식 (속도 30 ms 정도 더 빠르다.)

* 파이썬다운 방식은 파이썬의 기본 방식들을 활용하는 것이다.

```Python
    class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        # reverse()는 리스트에만 제공된다.
        s.reverse()
```

* 위의 코드 실행되어야 하는데 LeetCode에서 문제가 있어 실행되지 않는다. <br> 아래와 같은 방법을 활용하여 시간을 줄일 수 있다.

```Python
    class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        # 문자열 역순으로 슬라이싱해줬다.
        s[:] = s[::-1]
```
---

## LeetCode 937. Reorder Log Files 로그파일 재정렬

<https://leetcode.com/problems/reorder-data-in-log-files/submissions/>

---

###  람다와 + 연산자를 이용

```Python
    class Solution:
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        letter_logs, digit_logs = [], []
        for log in logs:
            # isdigit() 숫자여부를 판별하는 함수.
            if log.split()[1].isdigit():
                digit_logs.append(log)
            else:
                letter_logs.append(log)

        # 2개의 key를 람다표현식으로 정렬했다.        
        letter_logs.sort(key = lambda x: (x.split()[1:], x.split()[0]))
        
        return letter_logs + digit_logs
```

* 식별자를 제외한 문자열[1:]을 키로 하여 정렬하며, 동일한 경우 후순위로 식별자[0]을 지정해 정렬되도록,람다표현식을 이용했다.


### 람다표현식

* 식별자 없이 실행 가능한 함수를 말하며, 함수 선언 없이도 하나의 식으로 함수를 단순하게 표현할 수 있다. <br> 람다 표현식보다 더 간결하고 가독성이 좋은 리스트 컴프리헨션을 코딩테스트에 주로 사용한다. <br> 꼭 필요한 경우 람다표현식을 사용하게되는데 람다가 편리할 경우를 잘 선택해서 사용해야 한다.

```Python    
    s.sort(key = lambda x: (x.split()[1], x.split()[0]))
```

만약 s가 ['2 A', '1 B', '4 C', '1 A']라면 sorted()로 정렬한 결과는 다음과 같다. 
```Python
    >>> s = ['2 A', '1 B', '4 C', '1 A']  
    >>> sorted(s) 
    ['1 A', '1 B', '2 A', '4 C']
```

그러나, 우리가 원하는 결과는 각 요소의 번호 순 정렬이 아닌 그 뒤의 문자 순 정렬을 원하며,<br> 문자가 동일한 경우에만 그 앞 번호순으로 정렬되는 형태를 희망했다.
이 때, 리스트의 각 요소를 풀어서 별도 처리를 해줘야 하는데, 이럴 때 람다표현식을 사용할 수 있다.<br>

- 람다는 간단한 함수를 쉽게 선언하는 방법이라 할 수 있는 것이다.
```Python
    def func(x):
        return s.split()[1], x.split()[0]

    >>> s.sort(key=func)
    >>> s
    ['1 A', '2 A', '1 B', '4 C']
```
위 함수를 람다식으로 작성한다면 별도 함수 선언 없이도 간단하게 처리할 수 있다.

```Python
    >>> s.sort(key=lambda x: (x.split()[1], x.split()[0]))
    >>> s
    ['1 A', '2 A', '1 B', '4 C']
```

* 람다표현식 주의점: 코드가 길어지고 map이나 filter와 함께 섞어 사용하다보면<br> 가독성이 떨어지므로 주의가 필요하다.

---

## LeetCode 819. Most Common Word 가장 흔한 단어

<https://leetcode.com/problems/most-common-word/submissions/>

---

### 리스트 컴프리헨션, Counter 객체 사용.

```Python
    class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        # \w 는 단어 문자를 의미한다. 문자 + 숫자를 의미. [a-zA-Z0-9_] 와 동일하다.
        # re.sub(r) 여기서 r을 삽입하면 RawString 규칙에 의하여 백슬래시 2개 대신 1개만 써도 두 개를 쓴 것과 동일한 의미를 갖는다.
        words = [word for word in re.sub(r'[^\w]', ' ', paragraph).lower().split() if word not in banned ]
        
        counts = collections.defaultdict(int)
        for word in words:
            counts[word] += 1

        return max(counts, key=counts.get)
```
* 딕셔너리의 defaultdict()를 사용해 int 기본값이 자동으로 부여되게 했다. 따라서 key 존재 유무를 확인할 필요없이 즉시 counts[word]+=1 을 수행할 수 있다.<br>
딕셔너리 변수인 counts 에서 가장 큰 값의 키를 가져오기 위해서 max() 함수에 key를 지정해 argmax를 간접적으로 추출했다.<br> argamx() numpy에 존재하나 , 코딩테스트시에는 사용불가한 경우가 다수다. 외부라이브러리 사용금지때문.

---

* 개수를 처리하는 부분 Counter모듈을 사용해서 더 깔끔하게 처리할 수 있다.

```Python
    class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        words = [word for word in re.sub(r'[^\w]', ' ', paragraph).lower().split() if word not in banned ]
        
        counts = collections.Counter(words)
        
        return counts.most_common(1)[0][0]

```

* words에서 가장 흔하게 등장하는 단어의 첫 번째 값을 most_common(1)로 추출한다. <br> 두개 추출하고 싶으면 most_common(2) <br>
most_common(1)에서 추출된 것은 [('ball', 2)]가 되므로 이 값의 [0][0]을 추출해서 최종적으로 첫 번째 인덱스의 키를 추출한다.

---

## LeetCode 49.Group Anagrams 그룹 에너그램

<https://leetcode.com/problems/group-anagrams/>

---

### 풀이 1 정렬하여 딕셔너리에 추가.